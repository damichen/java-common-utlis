# java-common-utlis
记录一些java学习以及笔记工具类

# 代理
### 代理模式
#### 静态代理总结
- 可以做到在不修改目标对象的功能前提下,对目标功能扩展.
- 缺点:（可以使用动态代理来解决）
因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护.

#### 动态代理
动态代理有以下特点:
- 代理对象,不需要实现接口
- 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)
- 动态代理也叫做:JDK代理,接口代理

总结:
代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理

### 动态代理和cglib代理的区别？ 
- JDK代理只能对接口进行代理，Cglib则是对实现类进行代理
- cglib采用的是继承，所以不能对final修饰的类进行代理
- cglib代理对于final、static修饰的方法无法进行增强，只能按照原来的方法来执行，jdk代理不会有这个限制
- 从 jdk6 到 jdk7、jdk8 ，动态代理的性能得到了显著的提升，与cglib的性能上已经差别不大
- JDK实现方式产生的代理类是接口的实现,也就是说serviceProxy是可以赋值给IService的，但是不能赋值给ServiceImpl。对应Cglib则使用的继承机制，具体说被代理类和代理类是继承关系，所以代理类是可以赋值给被代理类的,如果被代理类有接口，那么代理类也可以赋值给接口
- 上边哪一点简单的说就是 jdk代理只能用接口来接收(interface=proxy.newInstance...);cglib 则可以返回接口或者实现类都行
  
### 简述⼀下 Spring AOP 的实现？
aop实现就是通过动态代理或者cglib代理来实现对目标对象的统一增强
